//! SeaORM Entity. Generated by sea-orm-codegen 0.3.2

use sea_orm::{entity::prelude::*, FromJsonQueryResult};
use serde::{Deserialize, Serialize};

use crate::sub_type::SubType;

#[derive(
    Clone, Debug, PartialEq, Eq, DeriveEntityModel, Serialize, Deserialize, FromJsonQueryResult,
)]
#[sea_orm(table_name = "transaction")]
pub struct Model {
    #[sea_orm(primary_key)]
    #[serde(skip_deserializing)]
    pub id: i64,
    pub wfm_id: String,
    pub wfm_url: String,
    pub item_name: String,
    pub item_type: TransactionItemType,
    pub item_unique_name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sub_type: Option<SubType>,
    pub tags: String,
    pub transaction_type: TransactionType,
    pub quantity: i64,
    pub user_name: String,
    pub price: i64,
    #[sea_orm(updated_at)]
    pub updated_at: DateTimeUtc,
    #[sea_orm(created_at)]
    pub created_at: DateTimeUtc,
    pub properties: Option<serde_json::Value>,
}
#[derive(Debug, Clone, PartialEq, sea_orm::EnumIter, sea_orm::DeriveActiveEnum)]
#[sea_orm(rs_type = "String", db_type = "String(Some(15))")]
#[derive(Eq)]
pub enum TransactionItemType {
    #[sea_orm(string_value = "item")]
    Item,
    #[sea_orm(string_value = "riven")]
    Riven,
}

impl TransactionItemType {
    pub fn from_str(s: &str) -> Self {
        match s {
            "item" => Self::Item,
            "riven" => Self::Riven,
            _ => panic!("Invalid transaction type"),
        }
    }
}
impl Serialize for TransactionItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let value = match self {
            TransactionItemType::Item => "item",
            TransactionItemType::Riven => "riven",
        };
        serializer.serialize_str(value)
    }
}

impl<'de> Deserialize<'de> for TransactionItemType {
    fn deserialize<D>(deserializer: D) -> Result<TransactionItemType, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s: String = String::deserialize(deserializer)?;
        Ok(match s.as_str() {
            "item" => TransactionItemType::Item,
            "riven" => TransactionItemType::Riven,
            _ => panic!("Invalid transaction type"),
        })
    }
}
#[derive(Debug, Clone, PartialEq, sea_orm::EnumIter, sea_orm::DeriveActiveEnum)]
#[sea_orm(rs_type = "String", db_type = "String(Some(15))")]
#[derive(Eq)]
pub enum TransactionType {
    #[sea_orm(string_value = "sale")]
    Sale,
    #[sea_orm(string_value = "purchase")]
    Purchase,
}

impl TransactionType {
    pub fn from_str(s: &str) -> Self {
        match s {
            "sale" => Self::Sale,
            "purchase" => Self::Purchase,
            _ => panic!("Invalid transaction type"),
        }
    }
}
impl Serialize for TransactionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let value = match self {
            TransactionType::Purchase => "purchase",
            TransactionType::Sale => "sale",
        };
        serializer.serialize_str(value)
    }
}

impl<'de> Deserialize<'de> for TransactionType {
    fn deserialize<D>(deserializer: D) -> Result<TransactionType, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s: String = String::deserialize(deserializer)?;
        Ok(match s.as_str() {
            "purchase" => TransactionType::Purchase,
            "sale" => TransactionType::Sale,
            _ => panic!("Invalid transaction type"),
        })
    }
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

impl Model {
    pub fn new(
        wfm_id: String,
        wfm_url: String,
        item_name: String,
        item_type: TransactionItemType,
        item_unique_name: String,
        sub_type: Option<SubType>,
        tags: Vec<String>,
        transaction_type: TransactionType,
        quantity: i64,
        user_name: String,
        price: i64,
        properties: Option<serde_json::Value>,
    ) -> Self {
        Self {
            id: Default::default(),
            wfm_id,
            wfm_url,
            item_name,
            item_type,
            item_unique_name,
            sub_type,
            tags: tags.join(","),
            transaction_type,
            quantity,
            user_name,
            price,
            properties,
            updated_at: Default::default(),
            created_at: Default::default(),
        }
    }
    pub fn get_metric_value(&self) -> String {
        let mut metric_value: String = String::new();
        metric_value.push_str(&format!("I:{}", self.wfm_id));
        metric_value.push_str(&format!("|IT:{:?}", self.item_type));
        metric_value.push_str(&format!("|T:{:?}", self.transaction_type));
        metric_value.push_str(&format!("|Q:{}", self.quantity));
        if let Some(sub_type) = self.sub_type.clone() {
            metric_value.push_str(&format!("{}", sub_type.get_metric_value()));
        }
        metric_value.push_str(&format!("|UN:{}", self.user_name));
        metric_value.push_str(&format!("|P:{}", self.price));
        metric_value.push_str(&format!("|PRO:{}", self.properties.as_ref().unwrap()));
        metric_value
    }
}
